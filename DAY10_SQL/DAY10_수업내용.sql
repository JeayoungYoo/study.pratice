-- DAY10 수업내용


-- 데이터 딕셔너리

-- 사용자가 만든 테이블 객체 정보 : USER_TABLES
DESC USER_TABLES;
SELECT * FROM USER_TABLES;

-- 사용자가 만든 제약조건 정보 : USER_CONSTRAINTS
DESC USER_CONSTRAINTS;
SELECT * FROM USER_CONSTRAINTS;

-- 사용자가 만든 시퀀스 객체 정보 : USER_SEQUENCES
DESC USER_SEQUENCES;
SELECT * FROM USER_SEQUENCES;

-- 사용자가 만든 인덱스 객체 정보 : USER_INDEXES
DESC USER_INDEXES;
SELECT * FROM USER_INDEXES;

-- 사용자가만든 뷰 객체 정보 : USER_VIEWS
DESC USER_VIEWS;
SELECT * FROM USER_VIEWS;

-- 현재 사용자가 접근할 수 있는 모든 테이블들을 조회 : ALL_TABLES
SELECT * FROM ALL_TABLES;

-- DBA(데이터베이스 관리자)가 접근할 수 있는 테이블 정보 : DBA_TABLES
SELECT * FROM DBA_TABLES;
-- SYSTEM 계정으로 로그인해서 조회함.

-- DDL (Data Definition Language)
-- CREATE, ALTER, DROP
-- 테이블 : CREATE TABLE, ALTER TABLE, DROP TABLE
-- 뷰 : CREATE VIEW, DROP VIEW
-- 시퀀스 : CREATE SEQUENCE, ALTER SEQUENCE, DROP SEQUENCE
-- 인덱스 : CREATE INDEX, DROP INDEX
-- 동의어 : CREATE SYNONYM, DROP SYNONYM


-- PLSQL 구문 : 오라클만 제공하는 구문임
-- 프로시져 : CREATE PROCEDURE, DROP PROCEDURE
-- 함수(FUNCTION) : CREATE FUNCTION, DROP FUNCTION
-- 트리거 : CREATE TRIGGER, DROP TRIGGER

-- 테이블 수정 : ATLER TABLE 테이블명 수정내용;
-- 수정할 수 있는 내용
-- 컬럼 추가/삭제, 제약조건 추가/삭제
-- 컬럼 자료형 변경, DEFAULT 값 변경
-- 테이블명 컬럼명, 제약조건이름 변경

-- 연습용 테이블 만들기 : DEPARTMENT 복사본 테이블 만들기
CREATE TABLE DEPTCPY
AS
SELECT * FROM DEPARTMENT;

SELECT * FROM DEPTCPY;
DESC DEPTCPY;

-- 컬럼 추가 : 테이블 생성시 컬럼 작성과 동일하게 하면 됨
ALTER TABLE DEPTCPY
ADD (LOC_NAME VARCHAR2(40));

DESC DEPTCPY;

ALTER TABLE DEPTCPY
ADD (CNAME VARCHAR2(30) DEFAULT ('한국'));

-- 제약조건 추가
ALTER TABLE DEPTCPY
ADD PRIMARY KEY (DEPT_ID);

ALTER TABLE DEPTCPY
ADD CONSTRAINT DCP_LOCID FOREIGN KEY (LOC_ID) REFERENCES LOCATION;

-- NOT NULL 제약조건 추가시에는 ADD 사용 못함

ALTER TABLE DEPTCPY
ADD NOT NULL (LOC_NAME);    -- ERROR

-- NOT NULL 제약조건은 추가시에 컬럼 수정으로 적용해야 함
ALTER TABLE DEPTCPY
MODIFY CNAME NOT NULL;

CREATE TABLE EMP4
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE;

ALTER TABLE EMP4
MODIFY (EMP_ID VARCHAR2(5),
EMP_NAME CHAR(20));

ALTER TABLE EMP4
MODIFY (HIRE_DATE CHAR(8));

ALTER TABLE EMP4
MODIFY (EMP_NAME CHAR(15));

CREATE TABLE EMP5
(EMP_ID CHAR(3),
EMP_NAME VARCHAR2(20),
ADDR1 VARCHAR2(20) DEFAULT '서울',
ADDR2 VARCHAR2(100));

INSERT INTO EMP5
VALUES ('A10','임태희', DEFAULT, '청담동');

INSERT INTO EMP5
VALUES ('B10', '이병언', DEFAULT, '분당 정자동');

SELECT * FROM EMP5;

ALTER TABLE EMP5
MODIFY (ADDR1 DEFAULT '경기');

INSERT INTO EMP5
VALUES ('C10', '임승우', DEFAULT, '분당 효자촌');

SELECT * FROM EMP5;

ALTER TABLE EMP4
DROP COLUMN EMP_ID;
또는
ALTER TABLE EMP4
DROP (EMP_ID);

DESC EMP4;

ALTER TABLE EMP5
DROP (EMP_ID, EMP_NAME);

DESC EMP5;

CREATE TABLE TB1
(PK NUMBER PRIMARY KEY,
FK NUMBER REFERENCES TB1,
COL1 NUMBER,
CHECK ( PK > 0 AND COL1 > 0 ));

ALTER TABLE TB1
DROP (PK) CASCADE CONSTRAINTS;
ALTER TABLE TB1
DROP (COL1)CASCADE CONSTRAINTS;

CREATE TABLE TCO(); -- 테이블은 반드시 한 개 이상의 컬럼을 가져야 한다.

ALTER TABLE DEPARTMENT
DROP (DEPT_ID); -- ERROR : 삭제할 컬럼을 참조하고 있는 컬럼(FK)이 있다면 삭제 못 한다.

ALTER TABLE DEPARTMENT
DROP ();

-- 제약조건 삭제
-- 샘플 테이블 만들기
CREATE TABLE CONST_EMP (
    ENAME VARCHAR2(20) CONSTRAINT NENAME1 NOT NULL,
    ENO VARCHAR2(14) CONSTRAINT NENO1 NOT NULL,
    MARRIAGE CHAR(1) DEFAULT 'N',
    EID CHAR(3),
    EMAIL VARCHAR2(30),
    JID CHAR(2),
    MID CHAR(3),
    DID CHAR(2),
    CONSTRAINT CHK1 CHECK (MARRIAGE IN ('N', 'Y')),
    CONSTRAINT PKEID1 PRIMARY KEY (EID),
    CONSTRAINT UENO1 UNIQUE (ENO),
    CONSTRAINT UEMAIL1 UNIQUE (EMAIL),
    CONSTRAINT FKJID1 FOREIGN KEY (JID) REFERENCES JOB (JOB_ID) ON DELETE SET NULL,
    CONSTRAINT FKMID1 FOREIGN KEY (MID) REFERENCES CONST_EMP ON DELETE SET NULL,
    CONSTRAINT FKDID1 FOREIGN KEY (DID) REFERENCES DEPARTMENT ON DELETE CASCADE
);

SELECT * FROM CONST_EMP;

-- 제약조건 삭제
-- 제약조건 1개 삭제
ALTER TABLE CONST_EMP
DROP CONSTRAINTS CHK1;

-- 제약조건 여러 개 삭제
ALTER TABLE CONST_EMP
DROP CONSTRAINT FKJID1
DROP CONSTRAINT FKMID1
DROP CONSTRAINT FKDID1;

-- 데이터 딕셔너리를 통해 삭제 확인해 봄
SELECT TABLE_NAME, CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME='CONST_EMP';

-- 기본키삭제
ALTER TABLE CONST_EMP
DROP CONSTRAINT PKEID1 CASCADE;

ALTER TABLE CONST_EMP
DROP CONSTRAINT NENAME1
DROP CONSTRAINT NENO1;


-- 테이블의 컬럼을 관리하는 데이터 딕셔너리 : USER_TAB_COLS
SELECT * FROM USER_TAB_COLS;
DESC USER_TAB_COLS;

-- 컬럼별 제약조건을 관리하는 데이터 딕셔너리 : USER_CON_COLS
CREATE TABLE TB_EXAM (
    COL1 CHAR(3) PRIMARY KEY,
    ENMAE VARCHAR2(20),
    FOREIGN KEY (COL1) REFERENCES EMPLOYEE
);

-- 딕셔너리를 이용한 컬럼별 제약조건 조회
SELECT CONSTRAINT_NAME AS 이름,
    CONSTRAINT_TYPE AS 유형,
    COLUMN_NAME AS 컬럼,
    R_CONSTRAINT_NAME AS 참조,
    DELETE_RULE AS 삭제규칙
FROM USER_CONSTRAINTS
JOIN USER_CONS_COLUMNS USING (CONSTRAINT_NAME, TABLE_NAME)
WHERE TABLE_NAME = 'TB_EXAM';


-- 이름 바꾸기 : 컬럼명, 제약조건 이름, 테이블명

-- 컬럼명 바꾸기
ALTER TABLE TB_EXAM
RENAME COLUMN COL1 TO EMPID;

DESC TB_EXAM;

-- 제약조건 이름 바꾸기
ALTER TABLE TB_EXAM
RENAME CONSTRAINTS SYS_C007160 TO PK_EID;

ALTER TABLE TB_EXAM
RENAME CONSTRAINTS SYS_C007161 TO FK_EID;

-- 테이블명 바꾸기
ALTER TABLE TB_EXAM
RENAME TO TB_SAMPLE1;

-- 또는
RENAME TB_SAMPLE1 TO TB_SAMPLE;

-- 테이블 삭제하기
CREATE TABLE DEPT(
    DID CHAR(2) PRIMARY KEY,
    DNAME VARCHAR2(10)
);

CREATE TABLE EMP6(
    EID CHAR(3) PRIMARY KEY,
    ENAME VARCHAR2(10),
    DID CHAR(2) REFERENCES DEPT
);
-- 참조되는 테이블을 삭제 못 함
DROP TABLE DEPT;

DROP TABLE DEPT CASCADE CONSTRAINTS;
-- DEPT 에 대한 REFERENCES 제약조건을 함께 삭제하라는 의미임

- VIEW 객체 ********************************************************
CREATE OR REPLACE VIEW V_RESULT_EMP
AS
SELECT EMP_ID, EMP_NAME, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN LOCATION ON (LOC_ID = LOCATION_ID);

SELECT * FROM V_RESULT_EMP;

SELECT * FROM USER_VIEWS;

CREATE OR REPLACE VIEW V_EMP
AS SELECT EMP_NAME, DEPT_ID
FROM EMPLOYEE
WHERE DEPT_ID = '90';

SELECT *
FROM V_EMP;

SELECT COLUMN_NAME, DATA_TYPE, NULLABLE
FROM USER_TAB_COLS
WHERE TABLE_NAME = 'V_EMP';

-- VIEW(뷰
-- SELECT 쿼리 실행의 결과를 보여주는 화면
-- 결과화면을 가상의 테이블처럼 저장해두고 사용할 수 있음
-- 마치 결과화면을 사진 찍어 보관한다는 의미임
-- 사용목적 :
-- 1. 보안에 유리 : 보관된 결과 화면만 봄으로써 쿼리문을 안 보이게 함
-- 2. 복잡하고 긴 쿼리문을 뷰를 통해 봄으로써 매번 쿼리문을 실행시키지 않아도 됨

/*
    CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW 뷰이름 (별칭, 별칭, 별칭 ...)
    AS 서브쿼리
    [WITH CHECK OPTION [CONSTRAINT 이름]]
    [WITH READ ONLY [CONSTRAINT 이름]];
    
    * CREATE OR REPLACE : 지정하는 뷰이름이 없으면 새로만들고,
                          동일 이름의 뷰가 존재하면 수정(OVERWRITE) 함
                          
    * FORCE | NOFORCE 
      FORCE : 베이스 테이블이 존재하지 않아도 뷰 생성
      NOFORCE (기본값) : 베이스 테이블이 존재하는 경우에만 뷰 생성됨
    
    * 별칭(ALIAS) : 뷰에서 사용할 이름 (테이블 컬럼명의 별칭을 의미함)
                    생략되면 서브쿼리의 SELECT 절에 나열된 컬럼명 그대로 사용함
                    ** 별칭의 갯수와 서브쿼리 SELECT 절의 컬럼의 갯수가 반드시 같아야 함
    
    * 제약조건
        - WITH CHECK OPTION : 뷰를 통해 접근 가능한 데이터에 대해서만 DML 수행 가능함
                              서브쿼리의 베이스 테이블이 1개일 때만 사용할 수 있음
        - WITH READ ONLY : 뷰를 통한 DML 허용 안 함
    * 권한 따로 부여해야 사용할 수 있음 (SYSTEM 계정)
        GRANT CREATE VIEW TO 사용자명;
        
*/

-- 뷰 만들기 : 서브쿼리를 사용함
-- 서브쿼리는 일반적은 SELECT 문을 의미함
-- 생성된 뷰를 테이블처럼 사용함

CREATE VIEW V_EMP_DEPT90
AS
SELECT EMP_NAME, DEPT_NAME, JOB_TITLE, SALARY
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
WHERE DEPT_ID = '90';

SELECT * FROM V_EMP_DEPT90;

-- 데이터 딕셔너리 USER_VIEWS 의 TEXT 컬럼에 서브쿼리문이 저장되어 있음
-- 뷰는 쿼리문 저장 객체로 볼 수도 있음

-- 실습
-- 직급명이 '사원'인 모든 직원들의 사원명, 부서명, 직급명, 입사일, 급여, 보너스포인트 조회
-- 단, 보너스포인트가 NULL 이면 0으로 처리
-- 결과를 뷰로 저장함 : 뷰이름 = V_EMP_DEPT_JOB

CREATE OR REPLACE VIEW V_EMP_DEPT_JOB
AS
SELECT EMP_NAME, DEPT_NAME, JOB_TITLE, HIRE_DATE, SALARY, NVL(BONUS_PCT, 0) AS BONUS_PCT
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE LIKE '사원';

SELECT * FROM V_EMP_DEPT_JOB;

CREATE OR REPLACE VIEW V_EMP_DEPT_JOB
AS
SELECT EMP_NAME, DEPT_NAME, JOB_TITLE, HIRE_DATE, SALARY, NVL(BONUS_PCT, 0) AS BONUS_PCT
FROM EMPLOYEE, DEPARTMENT, JOB
WHERE EMPLOYEE.DEPT_ID = DEPARTMENT.DEPT_ID(+) AND EMPLOYEE.JOB_ID = JOB.JOB_ID(+) AND JOB_TITLE LIKE '사원';


-- 뷰도 테이블처럼 딕셔너리에서 객체로 조회함

SELECT COLUMN_NAME, DATA_TYPE, NULLABLE
FROM USER_TAB_COLS
WHERE TABLE_NAME = 'V_EMP_DEPT_JOB';


-- 뷰 생성의 예
-- 
-- 또는 서브쿼리 부분에서 지정할 수도 있음
CREATE OR REPLACE VIEW V_EMP_DEPT_JOB (ENM, DNM, TITLE)
AS SELECT EMP_NAME, DEPT_NAME, JOB_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '사원';

SELECT * FROM V_EMP_DEPT_JOB;

-- 또는 
CREATE OR REPLACE VIEW V_EMP_DEPT_JOB
AS SELECT EMP_NAME AS ENM,
DEPT_NAME AS DNM,
JOB_TITLE AS TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '사원';

CREATE OR REPLACE VIEW V_EMP ("Enm", "Gender", "Years") AS
SELECT EMP_NAME,
DECODE(SUBSTR(EMP_NO, 8,1),'1','남자','3','남자','여자'),
ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12, 0)
FROM EMPLOYEE;

SELECT * FROM V_EMP;

CREATE OR REPLACE VIEW V_EMP_DEPT_JOB
AS SELECT EMP_NAME AS ENM,
DEPT_NAME AS DNM,
JOB_TITLE AS TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '사원';

SELECT * FROM V_EMP_DEPT_JOB;

CREATE OR REPLACE VIEW V_EMP ("Enm", "Gender", "Years") AS
SELECT EMP_NAME,
DECODE(SUBSTR(EMP_NO, 8,1),'1','남자','3','남자','여자'),
ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12, 0)
FROM EMPLOYEE;

SELECT * FROM V_EMP;

CREATE OR REPLACE VIEW V_EMP AS
SELECT EMP_NAME ,
DECODE(SUBSTR(EMP_NO, 8,1),'1','남자','3','남자','여자'),
ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12, 0)
FROM EMPLOYEE;

-- 특정 컬럼에 선택적으로 ALIAS를 지정하는 것은
-- 서브쿼리 부분에서만 가능

CREATE OR REPLACE VIEW V_EMP AS
SELECT EMP_NAME,
DECODE(SUBSTR(EMP_NO, 8,1),
'1','남자','3','남자','여자') AS "Gender",
ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12,0) AS "Years"
FROM EMPLOYEE;

-- 에러 : 뷰생성 부분에서는 전체 컬럼에 대해 지정해야 함
CREATE OR REPLACE VIEW V_EMP ("Gender", "Years") AS
SELECT EMP_NAME ,
DECODE(SUBSTR(EMP_NO, 8,1),'1','남자','3','남자','여자'),
ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12, 0)
FROM EMPLOYEE;  -- ERROR

CREATE OR REPLACE VIEW V_EMP
AS SELECT *
FROM EMPLOYEE
WITH READ ONLY;

-- DML 작업에 따라 에러 유형은 다르지만, DML 작업을 허용하지 않는다.
UPDATE V_EMP
SET PHONE = NULL; -- ERROE

INSERT INTO V_EMP (EMP_ID, EMP_NAME, EMP_NO)
VALUES ('666','오현정','666666-6666666'); -- ERROR

DELETE FROM V_EMP;  -- ERROR

-- WITH CHECK OPTION
-- 조건에 따라 INSERT / UPDATE 작업 제한
-- DELETE는 제한 없음
CREATE OR REPLACE VIEW V_EMP
AS SELECT EMP_ID, EMP_NAME, EMP_NO, MARRIAGE
FROM EMPLOYEE
WHERE MARRIAGE = 'N'
WITH CHECK OPTION; 

-- 에러
INSERT INTO V_EMP (EMP_ID, EMP_NAME, EMP_NO, MARRIAGE)
VALUES ('666','오현정','666666-6666666', 'Y');

-- 에러
UPDATE V_EMP
SET MARRIAGE = 'Y';

SELECT * FROM V_EMP;
-- 뷰를 생성할 때 사용한 WHERE 조건에 적용되는
-- 범위에서는 허용됨
SELECT * FROM V_EMP;
SELECT * FROM EMPLOYEE WHERE MARRIAGE = 'N';
UPDATE V_EMP
SET EMP_ID = '000'
WHERE EMP_ID = '124';

SELECT * FROM V_EMP;

ROLLBACK;

-- 뷰 생성시 사용한 서브쿼리 자체가 데이터 딕셔너리에 저장됨
-- USER_VIEWS : 뷰 정보를 관리하는 데이터 딕셔너리
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS
WHERE VIEW_NAME = 'V_EMP';

CREATE OR REPLACE VIEW V_EMP_INFO
AS SELECT EMP_NAME, DEPT_NAME, JOB_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID);

SELECT EMP_NAME
FROM V_EMP_INFO
WHERE DEPT_NAME = '해외영업1팀'
AND JOB_TITLE = '사원';

CREATE OR REPLACE VIEW V_DEPT_SAL ("Did", "Dnm", "Davg")
AS SELECT NVL(DEPT_ID,'N/A'),
NVL(DEPT_NAME,'N/A'),
ROUND(AVG(SALARY),-3)
FROM DEPARTMENT
RIGHT JOIN EMPLOYEE USING (DEPT_ID)
GROUP BY DEPT_ID, DEPT_NAME;

-- ""를 사용하여 ALIAS를 지정한 경우에는 ""까지 기술해야 함
SELECT "Dnm", "Davg"
FROM V_DEPT_SAL
WHERE "Davg" > 3000000;

-- "" 사용 안 하면 에러발생함 : 11G 정품에서는 에러 안 남.
SELECT Dnm, Davg
FROM V_DEPT_SAL
WHERE Davg > 3000000;

-- 뷰는 별도의 수정 구문 없음
ALTER VIEW V_DEPT_SAL
AS
SELECT * FROM EMPLOYEE;  -- ERROR

-- 뷰를 삭제하고 새로 생성해야 함
-- 또는 기존의 내용을 덮었써서 뷰가 수정되게 함
CREATE OR REPLACE VIEW V_EMP
AS
SELECT EMP_NAME, JOB_ID
FROM EMPLOYEE
WHERE SALARY > 3000000;

SELECT * FROM V_EMP;

-- 수정
CREATE OR REPLACE VIEW V_EMP
AS
SELECT EMP_NAME, JOB_ID
FROM EMPLOYEE
WHERE SALARY > 4000000;

-- 뷰 삭제
-- DROP VIEW 뷰이름;
DROP VIEW V_EMP;


-- FORCE 옵션 : 서브쿼리에서 사요된 테이블이 존재하지 않아도 뷰 생성됨
CREATE OR REPLACE FORCE VIEW V_EMP
AS
SELECT TCODE, TNAME, TCONTENET
FROM TTT;

-- NOFORCE 옵션 : 기본값, 서브쿼리에서 사용되는 테이블이 존재해야만 뷰 생성됨
-- 생략되면 NOFORCE 임
CREATE OR REPLACE VIEW V_EMP
AS
SELECT TCODE, TNAME, TPRICE
FROM TTT; -- 테이블이 존재하지지 않으면 에러남

-- 뷰 사용
CREATE OR REPLACE VIEW V_DEPT_SALAVG ("Did", "Davg");

SELECT NVL(DEPT_ID, 'N/A'),
ROUND(AVG(SALARY),-3)
FROM EMPLOYEE
GROUP BY DEPT_ID;
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
JOIN V_DEPT_SALAVG ON ( NVL(DEPT_ID, 'N/A') = "Did" )
WHERE SALARY > "Davg"
ORDER BY 2 DESC;

-- 뷰 사용
SELECT EMP_NAME, SALARY
FROM (SELECT NVL(DEPT_ID,'N/A') AS "Did",
ROUND(AVG(SALARY),-3) AS "Davg"
FROM EMPLOYEE
GROUP BY DEPT_ID) INLV
JOIN V_DEPT_SALAVG ON ( NVL(DEPT_ID, 'N/A') = INLV."Did" )
WHERE SALARY > INLV."Davg"
ORDER BY 2 DESC;


SELECT ROWNUM, EMP_NAME, SALARY
FROM (SELECT NVL(DEPT_ID,'N/A') AS "Did",
ROUND(AVG(SALARY),-3) AS "Davg"
FROM EMPLOYEE
GROUP BY DEPT_ID) INLV
JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV."Did")
WHERE SALARY > INLV."Davg";

SELECT ROWNUM, EMP_NAME, SALARY
FROM (SELECT NVL(DEPT_ID,'N/A') AS "Did",
ROUND(AVG(SALARY),-3) AS "Davg"
FROM EMPLOYEE
GROUP BY DEPT_ID) INLV
JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV."Did")
WHERE SALARY > INLV."Davg"
ORDER BY 3 DESC;

SELECT ROWNUM, EMP_NAME, SALARY
FROM (SELECT NVL(DEPT_ID,'N/A') AS "Did",
ROUND(AVG(SALARY),-3) AS "Davg"
FROM EMPLOYEE
GROUP BY DEPT_ID) INLV
JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV."Did")
WHERE SALARY > INLV."Davg"
AND ROWNUM = 3;

SELECT ROWNUM, EMP_NAME, SALARY
FROM (SELECT NVL(DEPT_ID,'N/A') AS "Did",
ROUND(AVG(SALARY),-3) AS "Davg"
FROM EMPLOYEE
GROUP BY DEPT_ID) INLV
JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV."Did")
WHERE SALARY > INLV."Davg"
AND ROWNUM = 1;

SELECT ROWNUM, EMP_NAME, SALARY
FROM ( SELECT EMP_NAME, SALARY
FROM (SELECT NVL(DEPT_ID,'N/A') AS "Did",
ROUND(AVG(SALARY),-3) AS "Davg"
FROM EMPLOYEE
GROUP BY DEPT_ID) INLV
JOIN EMPLOYEE ON ( NVL(DEPT_ID, 'N/A') = INLV."Did")
WHERE SALARY > INLV."Davg"
ORDER BY 2 DESC )
WHERE ROWNUM <= 5;
