-- DAY9 수업내용

-- 데이터 무결성 제약조건들(CONSTRAINTS)
-- 테이블에 입력되는 값들에 결점이 없게 하기위한 자동 검사기능을 의미함
-- 테이블 만들 때 해당 컬럼에 제약조건을 설정함
-- 테이블 만든 다음에 수정 적용할 수도 있음.

-- NOT NULL 제약조건
-- 컬럼에 값을 반드시 기록해야 됨 (필수입력항목을 뜻함)
-- 컬럼 레벨에서만 지정할 수 있는 제약조건임

CREATE TABLE TESTNN (
    NNID NUMBER(5) NOT NULL,    -- 컬럼 레벨
    NN_NAME VARCHAR2(20)
);

INSERT INTO TESTNN (NNID, NN_NAME)
-- VALUES (NULL, NULL);  -- NNID 에 NOT NULL 제약조건 위배됨
-- 에러
VALUES (NULL, 'ORACLE'); -- ERROR


INSERT INTO TESTNN
VALUES (1, NULL);

SELECT * FROM TESTNN;

-- 테이블 레벨 적용 예
CREATE TABLE TESTNN2 (
    NN_ID NUMBER(5) CONSTRAINT T2NNID NOT NULL,
    NN_NAME VARCHAR2(20)
    

    -- 테이블 레벨의 제약조건 작성 위치
    -- [CONSTRAINT 이름] 제약조건종류 (적용할컬럼명);
--    CONSTRAINT T2NNAME NOT NULL (NN_NAME)
    -- NOT NULL 제약조건은 테이블 레벨에서 설정할 수 없음
);


-- UNIQUE 제약조건
-- 해당 컬럼의 중복값(같은값 두번입력) 입력을 막는 제약조건임
-- 같은 값은 두 번 기록 못하는 컬럼이 됨
CREATE TABLE TESTUN (
    UN_ID CHAR(3) UNIQUE,
    UN_NAME VARCHAR2(10) NOT NULL
);

ROLLBACK;
INSERT INTO TESTUN
VALUES ('AAA', 'ORACLE'); --ERROR

INSERT INTO TESTUN
VALUES ('AAA', 'JAVA');

INSERT INTO TESTUN
VALUES ('AAB', 'JAVA');

INSERT INTO TESTUN
VALUES (NULL, 'JAVA');
-- UNIQUE 제약조건 컬럼에는 NULL 은 사용할 수 있음

SELECT *FROM TESTUN;

CREATE TABLE TESTUN2 (
    UN_ID2 CHAR(3) CONSTRAINT T2UN2 UNIQUE,
    UN_NAME2 VARCHAR2(10) CONSTRAINT T2UN2NN NOT NULL
);

CREATE TABLE TESTUN3 (
    UN_ID3 CHAR(3),
    UN_NAME3 VARCHAR2(10) CONSTRAINT T3UN3NN NOT NULL,
    CONSTRAINT T3UNID3 UNIQUE (UN_ID3)
);

CREATE TABLE TABLE_UNIQUE2 (
    ID CHAR(3), SNAME VARCHAR2(20), SCODE CHAR(2),
    CONSTRAINT TN2_ID_UN UNIQUE (ID,SNAME)
);

INSERT INTO TABLE_UNIQUE2
VALUES ('100', 'ORACLE', '01');

INSERT INTO TABLE_UNIQUE2
VALUES ('200', 'ORACLE', '01');   -- 2개의 커럼을 묶어서 하나의 값으로 봄

INSERT INTO TABLE_UNIQUE2
VALUES ('200','ORACLE','02');   -- 에러

SELECT * FROM TABLE_UNIQUE2;

-- UNIQUE 제약조건 설정 컬럼에는 NULL 사용할 수 있음
-- 단, 여러 개의 컬럼을 묶어서 UNIQUE 제약조건을 설정한 경우에는 주의 사용함
-- 묶은 컬럼 모두 NULL 일 때는 중복 사용 가능함
INSERT INTO TABLE_UNIQUE2
VALUES (NULL, NULL, '02');

INSERT INTO TABLE_UNIQUE2
VALUES (NULL, NULL, '03');

-- 묶여진 컬럼에 하나라도 값이 기록되면 중복 검사함
INSERT INTO TABLE_UNIQUE2
VALUES (NULL, 'JAVA', '04');

INSERT INTO TABLE_UNIQUE2
VALUES (NULL, 'JAVA', '05');   -- ERROR

SELECT * FROM TABLE_UNIQUE2;

CREATE TABLE TABLE_PK (
    ID CHAR(3) PRIMARY KEY,
    SNAME VARCHAR2(20)
);

-- PRIMARY KEY (기본키) 제약조건
-- 테이블에서 한 행의 정보를 찾기 위해 사용할 컬럼에 적용함
-- NOT NULL + UNIQUE
-- 한 테이블에 한 번만 사용할 수 있음

INSERT INTO TABLE_PK
VALUES ('100','ORACLE');

INSERT INTO TABLE_PK
VALUES ('100','IBM');  -- ERROR

INSERT INTO TABLE_PK
VALUES (NULL, 'SUN');  -- ERROR : ID 컬럼에 NULL 사용

-- 한 테이블 당 한 번만 설정할 수 있음
CREATE TABLE TESTPK2 (
    PID NUMBER PRIMARY KEY,
    PNAME VARCHAR2(15) PRIMARY KEY
);  -- ERROR

-- 컬럼레벨에서 이름 붙여 저장
CREATE TABLE TESTPK2 (
    PID NUMBER CONSTRAINT T2PID PRIMARY KEY,
    PNAME VARCHAR2(15),
    PDATE DATE
);

-- 테이블 레벨에서 이름 붙여 저장
CREATE TABLE TESTPK3 (
    PID NUMBER,
    PNAME VARCHAR2(15),
    PDATE DATE,
    CONSTRAINT T3PID PRIMARY KEY (PID)
);

CREATE TABLE TABLE_PK2 (
    ID CHAR(3),
    SNAME VARCHAR2(20),
    SCODE CHAR(2),
    CONSTRAINT TP2_PK PRIMARY KEY (ID,SNAME)
);

INSERT INTO TABLE_PK2
VALUES ('100','ORACLE','01');

INSERT INTO TABLE_PK2
VALUES ('200','ORACLE','01');


INSERT INTO TABLE_PK2
VALUES ('100','ORACLE','02');  -- ERROR : 2개를 묶어서 하나의 값으로 봄
-- 중복됨

INSERT INTO TABLE_PK2
VALUES (NULL,'ORACLE','01');  -- ERROR : 개별 컬럼에도 NULL 허용 안 함

SELECT * FROM TABLE_PK2;


-- CHECK : 커럼에 기록되는 값에 조건 설정을 할 수 있음
-- CHECK (컬럼명 연산자 비교값) : 비교값은 리터럴을 사용함, 함수 사용 못함.

CREATE TABLE TABLE_CHECK (
    EMP_ID CHAR(3) PRIMARY KEY,
    SALARY NUMBER CHECK ( SALARY > 0 ),
    MARRIAGE CHAR(1),
    CONSTRAINT CHK_MRG CHECK ( MARRIAGE IN ( 'Y','N' ) ) 
);

INSERT INTO TABLE_CHECK
VALUES ('100', -100, 'Y');   -- ERROR : SALARY 컬럼에 기록할 값이 음수임.

INSERT INTO TABLE_CHECK
VALUES ('100', 500, '?');  -- ERROR : 


CREATE TABLE TABLE_CHECK2 (
    ID CHAR(3) PRIMARY KEY,
    HIREDATE DATE CHECK ( HIREDATE < SYSDATE ) 
);  -- CHECK 조건에 함수 사용 못 함 (리터럴 : 값 만 사용할 수 있음)

CREATE TABLE TABLE_CHECK3 (
    EID CHAR(3) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    SALARY NUMBER ,
    MARRIAGE CHAR(1),
    CHECK ( SALARY > 0 AND SALARY < 1000000 )
);  -- 여러 조건을 설정할 수 있음.

CREATE TABLE TESTCHK (
    C_NAME VARCHAR2(15 CHAR) PRIMARY KEY,
    C_PRICE NUMBER(5) CONSTRAINT TCHK_PRICE CHECK (C_PRICE >= 1 AND C_PRICE <= 99999),
    C_LEVEL CHAR(1),
    C_DATE DATE CHECK (C_DATE > TO_DATE('2016/01/01', 'YYYY/MM/DD')),   -- BUG (함수사용 못함)
    CONSTRAINT TCHK_CLEVEL CHECK (C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C')
);

-- FOREIGN KEY (외부키/외래키/참조키) 제약조건
-- 다른 테이블에서 제공하는 값을 사용하는 컬럼 지정시 사용하는 제약조건
-- 연결된(참조하는 : REFERENCES) 테이블이 제공하는 값만 사용할 수 있음
-- NULL 은 사용할 수 있음.
-- 제공하는 값이 해당하는 컬럼은 반드시 기본키(PRIMARY KEY)이거나,
-- UNIQUE 제약조건이 설정된 컬럼만 적용할 수 있음

--[CONSTRAINT 저장할이름 FOREIGN KEY (적용할 컬럼명)]
-- REFERENCES 참조할테이블명 [(참조할컬럼명)]
-- 연결된 테이블의 지정 컬럼이 제공하지 않는 값을 사용하면 에러남.

CREATE TABLE TABLE_FK (
    ID CHAR(3),
    SNAME VARCHAR2(20),
    LID CHAR(2) REFERENCES LOCATION ( LOCATION_ID )
);

INSERT INTO TABLE_FK
VALUES ('200','ORACLE','C1');
-- ERROR : LOCATION 테이블의 LOCATION_ID 컬럼에 존재하지 않는 값을 사용하였음

CREATE TABLE TABLE_FK2 (
    ID CHAR(3),
    SNAME VARCHAR2(20),
    LID CHAR(2),
    CONSTRAINT FK1 FOREIGN KEY ( LID ) REFERENCES LOCATION ( LOCATION_ID )
);


CREATE TABLE TABLE_NOPK (
    ID CHAR(3),
    SNAME VARCHAR2(20)
);

CREATE TABLE TABLE_FK3 (
    ID CHAR(3) REFERENCES TABLE_NOPK,
    SNAME VARCHAR2(20)
);

CREATE TABLE TABLE_FK3 (
    ID CHAR(3) REFERENCES TABLE_NOPK(ID),
    SNAME VARCHAR2(20)
);  -- PRIMARY KEY 나 UNIQUE 컬럼이아님


-- FOREIGN KEY 제약조건 설정시 추가할 수 있는 삭제 옵션(선택사항)
-- DELETION OPTION
-- 기본 삭제룰은 부모키에 해당하는 컬럼 값은 절대 삭제 못 함

-- ON DELETE RESTRICT (기본값임)
-- 자식키가 잇는 부모키는 삭제 불가능
DELETE FROM DEPARTMENT
WHERE DEPT_ID = '90';  -- ERROR
-- EMPLOYEE 의 DEPT_ID 컬럼에서 '90'이 사용되고 있음

-- ON DELETE SET NULL
-- 부모키가 삭제되면 자식키는 NULL로 변경됨
CREATE TABLE EMPCPY (
    EMP_ID CHAR(3) PRIMARY KEY,
    DEPT_ID CHAR(2) REFERENCES DEPARTMENT ON DELETE SET NULL
);

INSERT INTO EMPCPY
VALUES ('111', '30');

SELECT * FROM EMPCPY;

DELETE FROM DEPARTMENT 
WHERE DEPT_ID = '30';

ROLLBACK;   -- 삭제 취소

-- ON DELETE CASCADE : 부모키 삭제시 자식 레코드 함께 삭제됨
CREATE TABLE EMPCPY2 (
    EMP_ID CHAR(3) PRIMARY KEY,
    DEPT_ID CHAR(2) REFERENCES DEPARTMENT ON DELETE CASCADE
);

INSERT INTO EMPCPY2
VALUES ('777', '30');

SELECT * FROM EMPCPY2;  -- 자식 레코드 삭제 확인

DELETE FROM DEPARTMENT
WHERE DEPT_ID = '30';

ROLLBACK;  -- 삭제 취소

-- 참조할 부모 테이블의 부모키가 조합 컬럼이면, 자식키도 컬럼을 조합해야 함
-- PRIMARY KEY (ID, SNAME) 일 경우, 또는 UNIQUE (ID, SNAME) 일 경우
-- FOREIGN KEY (ID, SNAME) 이어야 한다는 의미임.

    
CREATE TABLE CONSTRAINT_EMP
(EID CHAR(3) CONSTRAINT PKEID PRIMARY KEY,
ENAME VARCHAR2(20) CONSTRAINT NENAME NOT NULL,
ENO CHAR(14) CONSTRAINT NENO NOT NULL CONSTRAINT UENO UNIQUE,
EMAIL VARCHAR2(25) CONSTRAINT UEMAIL UNIQUE,
PHONE VARCHAR2(12),
HIRE_DATE DATE DEFAULT SYSDATE,
JID CHAR(2) CONSTRAINT FKJID REFERENCES JOB ON DELETE SET NULL,
SALARY NUMBER,
BONUS_PCT NUMBER,
MARRIAGE CHAR(1) DEFAULT 'N' CONSTRAINT CHK CHECK (MARRIAGE IN ('Y','N')),
MID CHAR(3) CONSTRAINT FKMID REFERENCES CONSTRAINT_EMP ON DELETE SET NULL,
DID CHAR(2),
CONSTRAINT FKDID FOREIGN KEY (DID) REFERENCES DEPARTMENT ON DELETE CASCADE
);

-- SELECT 문의 결과를 테이블에 기록 저장할 목적으로 사용함
CREATE TABLE TABLE_SUBQUERY1
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID);

SELECT * FROM TABLE_SUBQUERY1;

-- 테이블 구조 확인용 명령어 : DESCRIBE | DESC 테이블명;
DESC TABLE_SUBQUERY1;

-- 서브쿼리를 이용해서 기존의 테이블을 복사한 경우, 
-- 컬럼명, 자료형, NOT NULL 제약조건, DEFAULT 값도 복사됨
-- 나머지 제약조건들은 복사 안 됨.

-- 사번, 이름, 급여, 직급명, 부서명, 근무지역명, 소속국가명 조회
-- 조회한 결과를 EMP_LIST 테이블에 저장함

CREATE TABLE EMP_LIST AS
SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE
LEFT JOIN JOB USING (JOB_ID)
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN LOCATION ON (LOC_ID = LOCATION_ID)
LEFT JOIN COUNTRY USING (COUNTRY_ID);

SELECT * FROM EMP_LIST;

CREATE TABLE EMP_LIST AS
SELECT EMP_ID, EMP_NAME, SALARY, JOB_TITLE, DEPT_NAME, LOC_DESCRIBE, COUNTRY_NAME
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION LO, COUNTRY C
WHERE E.JOB_ID = J.JOB_ID(+) AND E.DEPT_ID = D.DEPT_ID(+) AND D.LOC_ID = LO.LOCATION_ID(+)
AND LO.COUNTRY_ID = C.COUNTRY_ID(+);

SELECT * FROM EMP_LIST;

CREATE TABLE EMP_MAN AS
SELECT * FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) IN ('1', '3');

DROP TABLE EMP_FEMAIL;

CREATE TABLE EMP_FEMAIL AS
SELECT * FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) IN ('2', '4');

CREATE TABLE PART_LIST AS
SELECT DEPT_NAME, JOB_TITLE, EMP_NAME, EMP_ID
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (EMPLOYEE.DEPT_ID = DEPARTMENT.DEPT_ID)
LEFT JOIN JOB ON (EMPLOYEE.JOB_ID = JOB.JOB_ID)
ORDER BY DEPARTMENT.DEPT_ID;

SELECT * FROM PART_LIST;

COMMENT ON COLUMN PART_LIST.DEPT_NAME IS '부서명';
COMMENT ON COLUMN PART_LIST.JOB_TITLE IS '직급명';
COMMENT ON COLUMN PART_LIST.EMP_NAME IS '사원명';
COMMENT ON COLUMN PART_LIST.EMP_ID IS '사번명';

CREATE TABLE PHONEBOOK (
    ID CHAR(3),
    PNAME VARCHAR2(20) CONSTRAINT NN_PBNAME NOT NULL,
    PHONE VARCHAR2(15) CONSTRAINT NN_PBPHONE NOT NULL,
    ADDRESS VARCHAR2(100) DEFAULT '서울시 구로구',
    CONSTRAINT PK_PBID PRIMARY KEY(ID),
    CONSTRAINT UN_PBPHONE UNIQUE (PHONE)
);

INSERT INTO PHONEBOOK
VALUES ('A01', '홍길동', '010-1234-5678', DEFAULT);

SELECT * FROM PHONEBOOK;

-- 데이터 딕셔너리 (사전)
-- 사용자가 생성한 모든 객체정보는 테이블 단위로 저장되고 있음
-- 예를 들면, 사용자가 만든 제약조건도 저장되고 있음
-- USER_CONSTRAINTS 

DESC USER_CONSTRAINTS;

SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'PHONEBOOK';

-- CONSTRAINT_TYPE 
-- P : PRIMARY KEY
-- U : UNIQUE
-- C : CHECK, NOT NULL
-- R : FOREIGN KEY

-- 서브쿼리를 가지고 테이블을 만들 때, 데이터는 복사하지 않고 
-- 구조만 복사할 경우 
-- 서브쿼리 WHERE 1 = 0 하면 됨
CREATE TABLE DEPT_COPY
AS
SELECT * FROM DEPARTMENT
WHERE 1 = 0;

SELECT * FROM DEPT_COPY;
DESC DEPT_COPY;

DESC DEPARTMENT;

-- 서브쿼리로 새 테이블 만들 때, 서브쿼리의 컬럼명을 사용하지 않고
-- 컬럼명을 다르게 구성할 수도 있다.
CREATE TABLE JOB_COPY (직급코드, 직급명, 최저급여, 최고급여)
AS
SELECT * FROM JOB;

DESC JOB_COPY;
SELECT * FROM JOB_COPY;

-- 서브쿼리 SELECT 절의 컬럼명에 별칭 붙여줘도 같은 결과를 얻음
CREATE TABLE DCOPY
AS
SELECT DEPT_ID DID, DEPT_NAME DNAME, LOC_ID LID
FROM DEPARTMENT;

DESC DCOPY;
SELECT * FROM DCOPY;

-- 서브쿼리로 새 테이블을 만들 때, 컬럼명을 바꾸면서 제약조건도 추가할 수 있음
-- 외부키 설정은 추가할 수 없음 (references 테이블명 (컬럼명))
CREATE TABLE TABLE_SUBQUERY3 (
    EID PRIMARY KEY,
    ENAME,
    SALARY CHECK (SALARY > 2000000),
    DNAME,
    JTITLE NOT NULL
) AS
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, NVL(JOB_TITLE, '미지정')
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
LEFT JOIN JOB USING (JOB_ID)
WHERE SALARY > 2000000;

SELECT * FROM TABLE_SUBQUERY3;

-- 데이터 딕셔너리로 확인해 봄
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, SEARCH_CONDITION
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_SUBQUERY3';







    