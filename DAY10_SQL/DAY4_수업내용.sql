-- DAY4 수업내용 : 함수

-- 단일행 함수 테스트
-- 날짜 처리 함수
-- SYSDATE 함수 : 시스템으로 부터 현재 날짜와 시간을 조회
SELECT SYSDATE
FROM DUAL;

-- 오라클에서는 환경설정, 객체 관련 정보들을 모두 저장관리하고 있음.
-- 데이터 딕셔너리(데이터 사전) 영역에 테이블의 형태로 각각 저장 관리하고 있음.
-- 데이터 딕셔너리는 DB 시스템이 관리함.
-- 저장된 정보를 조회할 수는 있음
-- 환경설정과 관련된 부분은 세팅 정보를 변경할 수 있음.

SELECT *
FROM SYS.NLS_SESSION_PARAMETERS;

-- 날짜 포멧과 관련된 변수만 조회
SELECT VALUE
FROM SYS.NLS_SESSION_PARAMETERS
WHERE PARAMETER = 'NLS_DATE_FORMAT';

-- 날짜 포멧 수정
ALTER SESSION
SET NLS_DATE_FORMAT = 'DD-MON-RR';

COMMIT;

-- 확인
SELECT SYSDATE FROM DUAL;

ALTER SESSION
SET NLS_DATE_FORMAT = 'RR/MM/DD';

COMMIT;

SELECT SYSDATE FROM DUAL;

SELECT EMP_NAME, HIRE_DATE, ADD_MONTHS( HIRE_DATE, 240 )
FROM EMPLOYEE;

-- 오늘 날짜에서 10년 뒤 날짜는?
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 120)
FROM DUAL;

-- 직원들 중에서 근무년수가 20년 이상된 직원 조회
-- 사번, 이름, 부서코드, 직급코드, 입사일 별칭 처리 조회
SELECT EMP_ID 사번, EMP_NAME 이름, DEPT_ID 부서코드, JOB_ID 직급코드, HIRE_DATE 입사일
FROM EMPLOYEE
WHERE ADD_MONTHS( HIRE_DATE, 240 ) < SYSDATE;

SELECT MONTHS_BETWEEN( '09/01/01', '09/03/14' )
FROM DUAL;

SELECT MONTHS_BETWEEN( '09/07/01', '09/03/14' )
FROM DUAL;

SELECT MONTHS_BETWEEN( '09/03/01', '09/03/01' )
FROM DUAL;

SELECT MONTHS_BETWEEN( '09/08/02', '09/06/02' )
FROM DUAL;

-- 직원들의 이름, 입사일, 현재까지의 근무일수, 근무개월수, 근무년수 조회
SELECT EMP_NAME 이름, HIRE_DATE 입사일, TRUNC(SYSDATE-HIRE_DATE) "현재까지의 근무일수",
TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) 근무개월수, TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12) 근무년수
FROM EMPLOYEE;

-- NEXT_DAY(날짜데이터 | 날짜가 기록된 컬럼명, '요일이름')
-- 지정된 날짜 뒤쪽 날짜에서 가장 가까운 해당 요일의 날짜를 리턴함
SELECT SYSDATE, NEXT_DAY(SYSDATE, '일요일')
FROM DUAL;

-- 데이터베이스의 사용 언어가 한국어로 지정이 되어 있기 때문에 요일이름을 한글로 사용함.
-- 영어로 요일이름 사용하면 에러남
SELECT SYSDATE, NEXT_DAY(SYSDATE, 'SUNDAY')
FROM DUAL;

-- 영어요일 이름을 사용하려면, 언어를 변ㄴ경해야 함
ALTER SESSION
SET NLS_LANGUAGE = AMERICAN;

COMMIT;

SELECT SYSDATE, NEXT_DAY(SYSDATE, 'SUNDAY')
FROM DUAL;

ALTER SESSION
SET NLS_LANGUAGE = KOREAN;

COMMIT;

-- LAST_DAY(날짜데이터 | 날짜가 기록된 컬럼명)
-- 지정한 날짜의 대한 마지막 날짜를 리턴함
SELECT LAST_DAY(SYSDATE)
FROM DUAL;

-- 직원 테이블에서 사원명, 입사일, 입사한 달의 근무일수 조회
SELECT EMP_NAME 사원명, HIRE_DATE 입사일, (LAST_DAY(HIRE_DATE)-HIRE_DATE) "입사한 달의 근무일수"
FROM EMPLOYEE;

-- 오늘 날짜 조회 함수
SELECT SYSDATE, SYSTIMESTAMP, CURRENT_DATE, CURRENT_TIMESTAMP
FROM DUAL;

-- SUBSTR() 함수로 입사년도, 입사월, 입사일 분리 추출 조회
SELECT SUBSTR(HIRE_DATE, 1, 2) 입사일, SUBSTR(HIRE_DATE, 4, 2) 입사월, SUBSTR(HIRE_DATE, 7, 2) 입사일
FROM EMPLOYEE;

-- EXTRACT(추출할 정보 FROM 날짜데이터) : 날짜데이터에서 원하는 정보만 추출
SELECT EXTRACT(YEAR FROM SYSDATE),
        EXTRACT(MONTH FROM SYSDATE),
        EXTRACT(DAY FROM SYSDATE)
FROM DUAL;

-- 직원의 이름, 입사일, 근무년수 조회
-- EXTRACT 사용

SELECT EMP_NAME 이름, HIRE_DATE 입사일, (EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE)) 근무년수
FROM EMPLOYEE;

SELECT EMP_NAME 이름, HIRE_DATE 입사일, FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE) / 12) 근무년수
FROM EMPLOYEE;

-- 형변환 함수
-- 자동형변환의 경우
SELECT 20 + '10' FROM DUAL;
-- 명시적 형변환
SELECT 20 + TO_NUMBER('10') FROM DUAL;

-- 자동형변환이 안 되는 경우
SELECT SYSDATE - '15/03/25' FROM DUAL;

-- 형변환해야 함
SELECT SYSDATE - TO_DATE('15/03/25', 'YY/MM/DD')
FROM DUAL;

SELECT SYSDATE - TO_DATE('2015년 3월 25일', 'YYYY"년" MM"월" DD"일"')
FROM DUAL;

SELECT TO_CHAR(1234, '99999'), TO_CHAR(1234, '09999'), TO_CHAR(1234, 'L99999'), TO_CHAR(1234, '99,999'), TO_CHAR(1234, '09,999'),
TO_CHAR(1000, '9.9EEEE'), TO_CHAR(1234, '999') 
FROM DUAL;

-- 사원명, 급여, 보너스포인트 조회
-- 급여는 앞에 통화단위 표시하고, 첫단위 구분기호도 표시함
-- 보너스포인트는 소숫점 아래 둘째자리까지 표시함

SELECT EMP_NAME 사원명, '\ '||TO_CHAR(SALARY, 'L99,999,999') 급여, TO_CHAR(NVL(BONUS_PCT, 0), '90.00') 보너스포인트
FROM EMPLOYEE;

SELECT TO_CHAR( SYSDATE, 'PM HH24:MI:SS' ), TO_CHAR(SYSDATE, 'AM HH:MI:SS' ), TO_CHAR( SYSDATE, 'MON DY, YYYY' ),
TO_CHAR(SYSDATE, 'YYYY-fmMM-DD DAY' ), TO_CHAR( SYSDATE, 'YYYY-MM-fmDD DAY' ), TO_CHAR( SYSDATE, 'Year, Q' )
FROM DUAL;

SELECT SYSDATE,
        TO_CHAR(SYSDATE, 'YYYY'), TO_CHAR(SYSDATE, 'RRRR'), 
        TO_CHAR(SYSDATE, 'YY'), TO_CHAR(SYSDATE, 'RR'),
        TO_CHAR(SYSDATE, 'YEAR')
FROM DUAL;

SELECT HIRE_DATE, 
        TO_CHAR(HIRE_DATE, 'YYYY "년"'), TO_CHAR(HIRE_DATE, 'RRRR "년"'),
        TO_CHAR(HIRE_DATE, 'YY'), TO_CHAR(HIRE_DATE, 'RR'),
        TO_CHAR(HIRE_DATE, 'YEAR')
FROM EMPLOYEE;

SELECT SYSDATE,
        TO_CHAR(SYSDATE, 'YYYY "년" MM "월"'),
        TO_CHAR(SYSDATE, 'MM'), TO_CHAR(SYSDATE, 'MONTH'),
        TO_CHAR(SYSDATE, 'MON'), TO_CHAR(SYSDATE, 'RM')
FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE, '"1년기준" DDD "일째"'), TO_CHAR(SYSDATE, '"1달기준" DD "일째"'),
                  TO_CHAR(SYSDATE, '"1주기준" D "일째"')
FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'Q"사분기"'), TO_CHAR(SYSDATE, 'DAY'), TO_CHAR(SYSDATE, 'DY')
FROM DUAL;

-- 직원 테이블에서 사원명, 입사일 조회
-- 입사일은 포멧을 적용해서 '2016년 05월 19일 (목)' 형식으로 출력 처리함

SELECT TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일" "("DY")"') 입사일
FROM EMPLOYEE;


SELECT EMP_NAME, HIRE_DATE,
        TO_CHAR(HIRE_DATE, 'YYYY-MM-DD AM HH:MI:SS'),
        TO_CHAR(HIRE_DATE, 'YYYY-fmMM-DD AM HH:MI:SS'),
        TO_CHAR(HIRE_DATE, 'YYYY-fmMM-DD HH24:MI:SS')
FROM EMPLOYEE
WHERE EMP_ID = 100;


-- 날짜데이터 비교연산시 시간을 가진 날짜데이터와 시간이 없는 날짜데이터는 비교 연산할 수 없음
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE = '90/04/01';  -- 결과 안 나옴

-- 해결방법
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE LIKE '90/04/01';

SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE TO_CHAR(HIRE_DATE, 'YY/MM/DD') = '90/04/01';

-- 날짜만 기록되어 있으면 날짜로 비교연산 할 수있음.
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE = '04/04/30';

SELECT EMP_NAME AS 이름,
TO_CHAR(HIRE_DATE, 'YYYY-MM-DD') AS 입사일
FROM EMPLOYEE
WHERE JOB_ID = 'J7';

SELECT EMP_NAME AS 이름,
TO_CHAR(HIRE_DATE, 'YYYY"년" MM"월" DD"일"') AS 입사일
FROM EMPLOYEE
WHERE JOB_ID = 'J7';

SELECT EMP_NAME AS 이름,
SUBSTR(HIRE_DATE,1,2)||'년 '||
SUBSTR(HIRE_DATE,4,2)||'월 '||
SUBSTR(HIRE_DATE,7,2)||'일' AS 입사일
FROM EMPLOYEE
WHERE JOB_ID = 'J7';

SELECT TO_DATE( '20100101', 'YYYYMMDD') FROM DUAL; -- 10/01/01
SELECT TO_CHAR( '20100101', 'YYYY, MON') FROM DUAL; -- N/A(오류)
SELECT TO_CHAR( TO_DATE( '20100101', 'YYYYMMDD'),
'YYYY, MON') FROM DUAL; -- 2010, 1월
SELECT TO_DATE( '041030 143000', 'YYMMDD HH24MISS' ) FROM DUAL; --04/10/30
SELECT TO_CHAR( TO_DATE( '041030 143000', 'YYMMDD HH24MISS' ),
'DD-MON-YY HH:MI:SS PM' ) FROM DUAL; -- 30-10월-04 02:30:00 오후
SELECT TO_DATE( '980630', 'YYMMDD' ) FROM DUAL; -- 98/06/30
SELECT TO_CHAR( TO_DATE( '980630', 'YYMMDD' ),
'YYYY.MM.DD') FROM DUAL; 

SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE = TO_DATE('900401 133030','YYMMDD HH24MISS');

SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE TO_CHAR(HIRE_DATE, 'YYMMDD') = '900401';

SELECT EMP_NAME, HIRE_DATE, TO_CHAR(HIRE_DATE, 'YYYY/MM/DD')
FROM EMPLOYEE
WHERE EMP_NAME = '한선기';

-- RR 과 YY 의 차이
-- 두자리 년도를 네자리 년도로 바꿀 때
-- 현재 년도 (16 : 50 보다 작음) 일때,
-- 바꿀 년도가 50미만이면 2000년도가 적용, 바꿀 년도가 50 이상이면 1900이 적용됨

SELECT HIRE_DATE, TO_CHAR(HIRE_DATE, 'RRRR'), TO_CHAR(HIRE_DATE, 'YYYY')
FROM EMPLOYEE;

-- 현재 년도와 바꿀 년도가 둘 다 50미만이면, Y, R 아무거나 사용해도 됨 : 현재 세기가 적용됨
SELECT TO_CHAR(TO_DATE('160505', 'YYMMDD'), 'YYYY-MM-DD'),
        TO_CHAR(TO_DATE('160505', 'RRMMDD'), 'RRRR-MM-DD'),
        TO_CHAR(TO_DATE('160505', 'YYMMDD'), 'RRRR-MM-DD'),
        TO_CHAR(TO_DATE('160505', 'RRMMDD'), 'YYYY-MM-DD')
FROM DUAL;

-- 현재 년도가 50미만이고, 바꿀 년도가 50이상일 때
-- 년도로 바꿀 때 Y 사용시 현재 세기(2000년) 으로 바뀜
-- R을 사용하면 이전 세기(1900년) 적용됨
SELECT TO_CHAR(TO_DATE('990101', 'YYMMDD'), 'YYYY-MM-DD'),
        TO_CHAR(TO_DATE('990101', 'RRMMDD'), 'RRRR-MM-DD'),
        TO_CHAR(TO_DATE('990101', 'YYMMDD'), 'RRRR-MM-DD'),
        TO_CHAR(TO_DATE('990101', 'RRMMDD'), 'YYYY-MM-DD')
FROM DUAL;

-- 결론 : 문자를 날짜로 바꿀 때 년도에 'R' 사용하면 됨

SELECT EMP_NAME, EMP_NO, SUBSTR(EMP_NO,1,6)AS 앞부분, SUBSTR(EMP_NO,8) AS 뒷부분, 
TO_NUMBER( SUBSTR(EMP_NO,1,6) ) + TO_NUMBER( SUBSTR(EMP_NO,8) ) AS 결과
FROM EMPLOYEE
WHERE EMP_ID = '101';

-- NVL(컬럼명, 컬럼의 값이 NULL 일 때 바꿀 값)
SELECT EMP_NAME, NVL(BONUS_PCT, 0.0), NVL(DEPT_ID, '00'), NVL(JOB_ID, 'J0')
FROM EMPLOYEE;

-- NVL2(컬럼명, 바꿀값1, 바꿀값2)
-- 해당 컬럼에 값이 있으면 바꿀값1로 바꾸고, NULL이면 바꿀값2로 바꿈

-- 직원 정보에서 보너스포인트가 0.2미만이거나 NULL인 직원들을 조회
-- 사번, 사원명, 보너스포인트, 변경보너스포인트

SELECT EMP_ID 사번, EMP_NAME 사원명, BONUS_PCT 변경전보너스포인트, NVL2(BONUS_PCT, 0.15, 0.05) 변경후보너스포인트
FROM EMPLOYEE
WHERE BONUS_PCT < 0.2 OR BONUS_PCT IS NULL;

SELECT EMP_NAME, DECODE(SUBSTR(EMP_NO,8,1), '1', '남', '2', '여', '3', '남', '4', '여') AS 성별
FROM EMPLOYEE
WHERE DEPT_ID = '50';

SELECT EMP_NAME, DECODE(SUBSTR(EMP_NO,8,1), '1', '남', '3', '남', '여') AS 성별
FROM EMPLOYEE
WHERE DEPT_ID = '50';

SELECT EMP_ID, EMP_NAME, DECODE(MGR_ID, NULL, '없음', MGR_ID) AS 관리자
FROM EMPLOYEE
WHERE JOB_ID = 'J4';

SELECT EMP_ID, EMP_NAME, NVL(MGR_ID, '없음') AS 관리자
FROM EMPLOYEE
WHERE JOB_ID = 'J4';

SELECT EMP_NAME, JOB_ID, SALARY, DECODE(JOB_ID, 'J7', SALARY*1.1, 'J6', SALARY*1.15, 'J5', SALARY*1.2, SALARY*1.05) AS 인상급여
FROM EMPLOYEE;

SELECT EMP_NAME, JOB_ID, SALARY,
CASE JOB_ID
      WHEN 'J7' THEN TO_CHAR(SALARY*1.1)
      WHEN 'J6' THEN TO_CHAR(SALARY*1.15)
      WHEN 'J5' THEN TO_CHAR(SALARY*1.2)
      ELSE TO_CHAR(SALARY*1.05) END AS 인상급여
FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, SALARY,
CASE WHEN SALARY <= 3000000 THEN '초급'
      WHEN SALARY <= 4000000 THEN '중급'
      ELSE '고급' END AS 구분
FROM EMPLOYEE
ORDER BY 구분; --오름차순 정렬 처리함